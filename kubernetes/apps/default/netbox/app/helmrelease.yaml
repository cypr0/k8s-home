---
# yaml-language-server: $schema=https://raw.githubusercontent.com/fluxcd-community/flux2-schemas/main/helmrelease-helm-v2.json
apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: netbox
spec:
  interval: 1h
  chartRef:
    kind: OCIRepository
    name: app-template
  install:
    remediation:
      retries: -1
  upgrade:
    cleanupOnFail: true
    remediation:
      retries: 3
  values:
    controllers:
      netbox:
        annotations:
          reloader.stakater.com/auto: "true"
        initContainers:
          fix-perms:
            image:
              repository: docker.io/library/alpine
              tag: 3.23.2@sha256:865b95f46d98cf867a156fe4a135ad3fe50d2056aa3f25ed31662dff6da4eb62
            command: ["sh", "-c", "mkdir -p /opt/unit/tmp/ && mkdir -p /opt/unit/state/certs && mkdir -p /opt/unit/state/scripts && chown -R 3000:3000 /opt/unit/"]
            securityContext:
              runAsUser: 0
              runAsGroup: 0
        containers:
          app:
            image:
              repository: netboxcommunity/netbox
              tag: v4.4@sha256:8c4086fdda5099274d6163aa117a8efbfd7d3dafaaf45316443a9cf54823996a
            env:
              TIME_ZONE: ${TIMEZONE}
              CORS_ORIGIN_ALLOW_ALL: true
              DB_WAIT_DEBUG: "10"
              HOUSEKEEPING_INTERVAL: "86400"
              REMOTE_AUTH_ENABLED: true
              REMOTE_AUTH_BACKEND: social_core.backends.open_id_connect.OpenIdConnectAuth
              SOCIAL_AUTH_OIDC_OIDC_ENDPOINT: https://id.${SECRET_DOMAIN}/application/o/netbox/
              SOCIAL_AUTH_OIDC_KEY: ${NETBOX_OPENID_CLIENT_ID}
              SOCIAL_AUTH_OIDC_SECRET: ${NETBOX_OPENID_CLIENT_SECRET}
              SOCIAL_AUTH_OIDC_SCOPE: openid profile email roles
              LOGOUT_REDIRECT_URL: https://id.${SECRET_DOMAIN}/application/o/netbox/end-session/
              EMAIL_FROM: "Netbox <mail@${SECRET_DOMAIN}>"
              EMAIL_PORT: 25
              EMAIL_SERVER: ${SECRET_MAIL_SERVER}
              EMAIL_TIMEOUT: 30
              GRAPHQL_ENABLED: true
              MEDIA_ROOT: /opt/netbox/netbox/media
              METRICS_ENABLED: false
              REDIS_CACHE_DATABASE: 7
              REDIS_CACHE_HOST: dragonfly.database.svc.cluster.local
              REDIS_CACHE_PORT: "6379"
              REDIS_CACHE_PASSWORD: ${DRAGONFLY_PASSWORD}
              REDIS_DATABASE: 8
              REDIS_HOST: dragonfly.database.svc.cluster.local
              REDIS_PORT: "6379"
              REDIS_PASSWORD: ${DRAGONFLY_PASSWORD}
              REDIS_URL: "redis://:${DRAGONFLY_PASSWORD}@dragonfly.database.svc.cluster.local:6379/8"
              REDIS_CACHE_URL: "redis://:${DRAGONFLY_PASSWORD}@dragonfly.database.svc.cluster.local:6379/7"
              RELEASE_CHECK_URL: https://api.github.com/repos/netbox-community/netbox/releases
              WEBHOOKS_ENABLED: true
              SKIP_SUPERUSER: true
            envFrom:
              - secretRef:
                  name: netbox-secret
            probes:
              liveness: &probes
                enabled: true
                custom: true
                spec:
                  httpGet:
                    path: /login/
                    port: &port 8080
                  initialDelaySeconds: 60
                  periodSeconds: 10
                  timeoutSeconds: 5
                  failureThreshold: 3
              readiness: *probes
              startup:
                enabled: true
                spec:
                  httpGet:
                    path: /login/
                    port: *port
                  initialDelaySeconds: 0
                  periodSeconds: 10
                  timeoutSeconds: 5
                  failureThreshold: 30
            resources:
              requests:
                cpu: 10m
                memory: 512Mi
              limits:
                memory: 2Gi
            securityContext:
              runAsUser: 3000
              runAsGroup: 3000
              fsGroup: 3000
              fsGroupChangePolicy: OnRootMismatch
              seccompProfile: { type: RuntimeDefault }
    service:
      app:
        controller: netbox
        ports:
          http:
            port: *port
    route:
      app:
        hostnames: ["netbox.${SECRET_DOMAIN}"]
        parentRefs:
          - name: external
            namespace: kube-system
            sectionName: https
        rules:
          - backendRefs:
              - name: netbox
                port: *port
    configMaps:
      auth-config:
        enabled: true
        data:
          authentik.py: |
            from os import environ

            # python-social-auth configuration
            SOCIAL_AUTH_OIDC_OIDC_ENDPOINT = environ.get('SOCIAL_AUTH_OIDC_OIDC_ENDPOINT')
            SOCIAL_AUTH_OIDC_KEY = environ.get('SOCIAL_AUTH_OIDC_KEY')
            SOCIAL_AUTH_OIDC_SECRET = environ.get('SOCIAL_AUTH_OIDC_SECRET')
            SOCIAL_AUTH_OIDC_SCOPE = environ.get('SOCIAL_AUTH_OIDC_SCOPE').split(' ')
            LOGOUT_REDIRECT_URL = environ.get('LOGOUT_REDIRECT_URL')

            SOCIAL_AUTH_PIPELINE = (
                ###################
                # Default pipelines
                ###################

                # Get the information we can about the user and return it in a simple
                # format to create the user instance later. In some cases the details are
                # already part of the auth response from the provider, but sometimes this
                # could hit a provider API.
                'social_core.pipeline.social_auth.social_details',

                # Get the social uid from whichever service we're authing thru. The uid is
                # the unique identifier of the given user in the provider.
                'social_core.pipeline.social_auth.social_uid',

                # Verifies that the current auth process is valid within the current
                # project, this is where emails and domains whitelists are applied (if
                # defined).
                'social_core.pipeline.social_auth.auth_allowed',

                # Checks if the current social-account is already associated in the site.
                'social_core.pipeline.social_auth.social_user',

                # Make up a username for this person, appends a random string at the end if
                # there's any collision.
                'social_core.pipeline.user.get_username',

                # Send a validation email to the user to verify its email address.
                # Disabled by default.
                # 'social_core.pipeline.mail.mail_validation',

                # Associates the current social details with another user account with
                # a similar email address. Disabled by default.
                # 'social_core.pipeline.social_auth.associate_by_email',

                # Create a user account if we haven't found one yet.
                'social_core.pipeline.user.create_user',

                # Create the record that associates the social account with the user.
                'social_core.pipeline.social_auth.associate_user',

                # Populate the extra_data field in the social record with the values
                # specified by settings (and the default ones like access_token, etc).
                'social_core.pipeline.social_auth.load_extra_data',

                # Update the user record with any changed info from the auth service.
                'social_core.pipeline.user.user_details',


                ###################
                # Custom pipelines
                ###################
                # Set authentik Groups
                'netbox.custom_pipeline.add_groups',
                'netbox.custom_pipeline.remove_groups',
                # Set Roles
                'netbox.custom_pipeline.set_roles'
            )
      auth-pipeline:
        enabled: true
        data:
          custom_pipeline.py: |
            # from django.contrib.auth.models import Group # For Netbox < 4.0.0
            from netbox.authentication import Group # For Netbox >= 4.0.0

            class AuthFailed(Exception):
                pass

            def add_groups(response, user, backend, *args, **kwargs):
                try:
                    groups = response['groups']
                except KeyError:
                    pass

                # Add all groups from oAuth token
                for group in groups:
                    group, created = Group.objects.get_or_create(name=group)
                    # group.user_set.add(user) # For Netbox < 4.0.0
                    user.groups.add(group) # For Netbox >= 4.0.0

            def remove_groups(response, user, backend, *args, **kwargs):
                try:
                    groups = response['groups']
                except KeyError:
                    # Remove all groups if no groups in oAuth token
                    user.groups.clear()
                    pass

                # Get all groups of user
                user_groups = [item.name for item in user.groups.all()]
                # Get groups of user which are not part of oAuth token
                delete_groups = list(set(user_groups) - set(groups))

                # Delete non oAuth token groups
                for delete_group in delete_groups:
                    group = Group.objects.get(name=delete_group)
                    # group.user_set.remove(user) # For Netbox < 4.0.0
                    user.groups.remove(group) # For Netbox >= 4.0.0


            def set_roles(response, user, backend, *args, **kwargs):
                # Remove Roles temporary
                user.is_superuser = False
                user.is_staff = False
                try:
                    groups = response['groups']
                except KeyError:
                    # When no groups are set
                    # save the user without Roles
                    user.save()
                    pass

                # Set roles is role (superuser or staff) is in groups
                user.is_superuser = True if 'superusers' in groups else False
                user.is_staff = True if 'staff' in groups else False
                user.save()
    persistence:
      data:
        existingClaim: netbox-pvc
        globalMounts:
          - path: /opt/netbox/netbox/media
      unit:
        type: emptyDir
        globalMounts:
          - path: /opt/unit/
      auth-config:
        type: configMap
        name: netbox-auth-config
        advancedMounts:
          netbox:
            app:
              - path: /etc/netbox/config/authentik.py
                subPath: authentik.py
                readOnly: true
      auth-pipeline:
        type: configMap
        name: netbox-auth-pipeline
        advancedMounts:
          netbox:
            app:
              - path: /opt/netbox/netbox/netbox/custom_pipeline.py
                subPath: custom_pipeline.py
                readOnly: true
